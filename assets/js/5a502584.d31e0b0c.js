"use strict";(self.webpackChunkexperimenter_docs=self.webpackChunkexperimenter_docs||[]).push([[3581],{4137:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>h});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},m="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),m=c(n),d=i,h=m["".concat(l,".").concat(d)]||m[d]||u[d]||r;return n?a.createElement(h,o(o({ref:t},p),{},{components:n})):a.createElement(h,o({ref:t},p))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,o=new Array(r);o[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[m]="string"==typeof e?e:i,o[1]=s;for(var c=2;c<r;c++)o[c]=n[c];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},3425:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>r,metadata:()=>s,toc:()=>c});var a=n(7462),i=(n(7294),n(4137));const r={id:"bucketing",title:"Bucketing",slug:"/bucketing"},o=void 0,s={unversionedId:"deep-dives/data/bucketing",id:"deep-dives/data/bucketing",title:"Bucketing",description:"Bucketing is the process of randomly assigning users to experiment branches. When a user is \u201cbucketed\u201d into an experiment, it means that the configuration in one of its branches (such as a change to part of the UI) can be activated, and that any interactions we record from that moment on can be associated with the experiment and branch identifier.  The concept is explained in this video / presentation.",source:"@site/docs/deep-dives/data/bucketing.md",sourceDirName:"deep-dives/data",slug:"/bucketing",permalink:"/bucketing",draft:!1,editUrl:"https://github.com/mozilla/experimenter-docs/edit/main/docs/deep-dives/data/bucketing.md",tags:[],version:"current",frontMatter:{id:"bucketing",title:"Bucketing",slug:"/bucketing"},sidebar:"sidebar",previous:{title:"Adding a Platform",permalink:"/deep-dives/jetstream/adding-a-platform"},next:{title:"Missing Exposure-based Analysis?",permalink:"/missing-exposure"}},l={},c=[{value:"Assumptions",id:"assumptions",level:2},{value:"Implementation",id:"implementation",level:2},{value:"Configuration",id:"configuration",level:3},{value:"Randomization Unit",id:"randomization-unit",level:3},{value:"Experiment assignment",id:"experiment-assignment",level:3},{value:"Namespace rollovers",id:"namespace-rollovers",level:4},{value:"Branch assignment",id:"branch-assignment",level:3},{value:"Controlling interactions",id:"controlling-interactions",level:3},{value:"Bucket range exclusion",id:"bucket-range-exclusion",level:4},{value:"Client-side rules",id:"client-side-rules",level:4},{value:"Targeting exclusion",id:"targeting-exclusion",level:4}],p={toc:c},m="wrapper";function u(e){let{components:t,...n}=e;return(0,i.kt)(m,(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Bucketing")," is the process of randomly assigning users to experiment branches. When a user is \u201cbucketed\u201d into an experiment, it means that the configuration in one of its branches (such as a change to part of the UI) can be activated, and that any interactions we record from that moment on can be associated with the experiment and branch identifier.  The concept is explained in this ",(0,i.kt)("a",{parentName:"p",href:"https://mozilla.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=c5fe3f48-322f-48ca-92d8-adc8014a3cb4&start=10"},"video")," / ",(0,i.kt)("a",{parentName:"p",href:"https://docs.google.com/presentation/d/18Xid6FNyC207Hqfhm3OtVDBxNCbVx9Ku9Hvqc_PJVU4/edit#slide=id.g82761e80df_0_1948"},"presentation"),".  "),(0,i.kt)("admonition",{title:"which experiments?",type:"info"},(0,i.kt)("p",{parentName:"admonition"},'This documentation applies to experiments launched to Desktop, iOS, and Android Firefox through the "Nimbus" or "Normandy" systems. Differences between platforms are noted when relevant.')),(0,i.kt)("h2",{id:"assumptions"},"Assumptions"),(0,i.kt)("p",null,"In order to support the analysis of controlled experiments, we must be able to satisfy the following functional requirements:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"We can randomly assign users to one or more branches of of an experiment."),(0,i.kt)("li",{parentName:"ul"},"A single user can enroll in multiple experiments simultaneously."),(0,i.kt)("li",{parentName:"ul"},"We can specify certain characteristics about a client that must be met for a client to bucket into an experiment, such as region."),(0,i.kt)("li",{parentName:"ul"},"We can assign users to unevenly distributed branches(e.g. 10% to A, 90% to B)"),(0,i.kt)("li",{parentName:"ul"},"We can control interactions between experiments (i.e. ensure experiments do not overlap) when we want to."),(0,i.kt)("li",{parentName:"ul"},"We can observe which users have bucketed into which experiments/branches and when.")),(0,i.kt)("p",null,"We assume the following statistical requirements:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Assignment of targeted clients to branches is uniformly random with respect to all observables. If we were to look at the set of users for each branch (where unique users are identified by the randomization unit), we should see roughly the same distribution of locale, location, profile age, etc."),(0,i.kt)("li",{parentName:"ul"},"Branch assignment must not depend on anything the user can influence."),(0,i.kt)("li",{parentName:"ul"},"Actual enrollment is probabilistically equal to the percentage of total traffic allocated to that branch. e.g. If we configured an experiment with two equal branches to enroll 10% of the population, we should see 5% of the total population enroll in each branch."),(0,i.kt)("li",{parentName:"ul"},"Enrollment in a branch is deterministic. Given the same experiment configuration, interaction rules, and user identifier, the result should always be the same. Shipping a new experiment must not change the basis for assigning a client to a branch."),(0,i.kt)("li",{parentName:"ul"},"Enrollment in a branch is persistent. Once a user is bucketed into a branch, they should continue to see the same branch for the duration of the experiment."),(0,i.kt)("li",{parentName:"ul"},"We should be able to control undesired interactions between experiments based on the specific requirements of our system. For example, as a first step, we can\u2019t enroll users in more than one branch that contains configuration for the same feature.")),(0,i.kt)("h2",{id:"implementation"},"Implementation"),(0,i.kt)("p",null,"At a high level, we bucket users into experiments client-side by taking a hash of a ",(0,i.kt)("a",{parentName:"p",href:"#randomization-unit"},"randomly generated user id")," and some configuration delivered from our experimentation servers. Assignment happens when configuration is synced to the client and sends enrollment telemetry."),(0,i.kt)("h3",{id:"configuration"},"Configuration"),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"This example uses the Nimbus experiment format. While the Normandy format is different, the client-side algorithm is almost identical. Many fields have been omitted for brevity.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "slug": "my-cool-test",\n  "targeting": "browserSettings.update.channel == \'release\'",\n  "bucketConfig": {\n    "start": 5000,\n    "count": 2000,\n    "total": 10000,\n    "namespace": "aboutwelcome-1",\n    "randomizationUnit": "normandy_id"\n  },\n\n  "branches": [\n    { "slug": "control", "ratio": 1 },\n    { "slug": "treatment", "ratio": 1 }\n  ]\n}\n')),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"targeting")," specifies conditions that must be met before the client can be considered. In this case, the user must in the release channel (beta or nightly users will not be considered)."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"count")," is a fraction of ",(0,i.kt)("inlineCode",{parentName:"li"},"total")," representing the chance of getting bucketed. In this case, the chance is 20%."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"start"),' is an integer representing a "range" of buckets, which allows for ',(0,i.kt)("a",{parentName:"li",href:"#controlling-interactions"},"isolation of experiments")," along a single ",(0,i.kt)("inlineCode",{parentName:"li"},"namespace"),". In this example, the start is set to 5000, which would isolate it from users in an existing experiment with a ",(0,i.kt)("inlineCode",{parentName:"li"},"start")," of 0 and a ",(0,i.kt)("inlineCode",{parentName:"li"},"count")," of 5000.")),(0,i.kt)("h3",{id:"randomization-unit"},"Randomization Unit"),(0,i.kt)("p",null,"Bucketing uses a stable unique identifier generated at startup. Note that this identifier is ",(0,i.kt)("em",{parentName:"p"},"not")," ",(0,i.kt)("inlineCode",{parentName:"p"},"client_id"),", which is the standard unit for aggregation for most data analysis in Firefox."),(0,i.kt)("p",null,"Desktop experiments use the ",(0,i.kt)("inlineCode",{parentName:"p"},"normandy_id"),", a unique stable identifier generated by the ",(0,i.kt)("inlineCode",{parentName:"p"},"ClientEnvironment")," module during first run and stored in a preference (see ",(0,i.kt)("a",{parentName:"p",href:"https://searchfox.org/mozilla-central/source/toolkit/components/utils/ClientEnvironment.jsm#99"},"implementation"),"). It differs from ",(0,i.kt)("inlineCode",{parentName:"p"},"client_id")," in that it is ",(0,i.kt)("em",{parentName:"p"},"not")," exposed to Telemetry and it is not synced across profiles / accounts."),(0,i.kt)("p",null,"Mobile experiments use the ",(0,i.kt)("inlineCode",{parentName:"p"},"nimbus_id"),", a unique identifier generated by the Nimbus client during first run stored in the experiments database (see ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/mozilla/application-services/blob/866c72cddc4d925a0dc1a83c9aeebd2e878be85e/components/nimbus/src/lib.rs#L433"},"implementation"),")."),(0,i.kt)("h3",{id:"experiment-assignment"},"Experiment assignment"),(0,i.kt)("p",null,"In order to randomize clients into experiments, we take a SHA-256 hash of the ",(0,i.kt)("inlineCode",{parentName:"p"},"namespace")," and the ",(0,i.kt)("inlineCode",{parentName:"p"},"randomization_unit")," truncated to 12 characters and check if that falls between the bucket range configured in the experiment."),(0,i.kt)("p",null,"Consider this example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "slug": "experiment-B",\n  "bucketConfig": {\n    "start": 3000,\n    "count": 2000,\n    "total": 10000,\n    "namespace": "rutabaga",\n    "randomizationUnit": "normandy_id"\n  }\n}\n')),(0,i.kt)("p",null,"A client will be bucketed into the experiment if the input hash falls in the range ",(0,i.kt)("inlineCode",{parentName:"p"},"3000")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"4999"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"                  start\n                  |     hash\n                  v     v\n  [0, 1000, 2000, 3000, 4000, 5000, 6000, 7000, 8000, 9000]\n                              ^\n                              end\n")),(0,i.kt)("h4",{id:"namespace-rollovers"},"Namespace rollovers"),(0,i.kt)("p",null,"When a ",(0,i.kt)("inlineCode",{parentName:"p"},"namespace")," is fully consumed (i.e., an experiment requests a bucket range beyond ",(0,i.kt)("inlineCode",{parentName:"p"},"9999"),'), the namespace "rolls over". The namespace ID is updated from something like ',(0,i.kt)("inlineCode",{parentName:"p"},"<application>-<feature>-<channel>-1")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"<application>-<feature>-<channel>-2")," and the clients are effectively rehashed to form 10000 new buckets. When an experiment launches on this new namespace, some fraction of the requested client range is already enrolled into an experiment (unlike a non-rollover situation where the requested client range is guaranteed to yield available clients) and so ",(0,i.kt)("em",{parentName:"p"},"experiments will under-enroll their desired amount"),"."),(0,i.kt)("p",null,"As an example, suppose that 75% of the namespace has been consumed by experiments that ",(0,i.kt)("em",{parentName:"p"},"have ended")," and that 20% of the namespace is consumed by an active experiment called ",(0,i.kt)("inlineCode",{parentName:"p"},"A")," (i.e., ",(0,i.kt)("inlineCode",{parentName:"p"},"A")," is live with a ",(0,i.kt)("inlineCode",{parentName:"p"},"bucketConfig")," of ",(0,i.kt)("inlineCode",{parentName:"p"},'{"start":7500, "end":9500", "total":10000}'),"). Suppose further that another 20% experiment called ",(0,i.kt)("inlineCode",{parentName:"p"},"B")," is launched. In that situation, the namespace will rollover and buckets ",(0,i.kt)("inlineCode",{parentName:"p"},"0000")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"2000")," of the new namespace will be allocated to ",(0,i.kt)("inlineCode",{parentName:"p"},"B"),". Some fraction of ",(0,i.kt)("inlineCode",{parentName:"p"},"B"),"'s clients (approximately 20%) will still be enrolled in ",(0,i.kt)("inlineCode",{parentName:"p"},"A"),", so even though they meet the enrollment criteria, they will not enroll. Thus, ",(0,i.kt)("inlineCode",{parentName:"p"},"B")," will actually enroll 16% of the available userspace, even though it targeted 20%."),(0,i.kt)("p",null,"In practices, experiments can run indefinitely and namespaces can rollover indefinitely so one must account for any running experiment on any prior iteration of the namespace, not just the previous iteration. That said, the impact of this effect is moderated by retention (or lack thereof) in that a 1 year old experiment using 20% of the clients will only block some fraction less, maybe 10%, because clients have churned and many of the clients in that experiment have dropped while new clients have joined after that experiment enrolled. Further, the impact of this effect depends on the targeting itself. For example, experiments targeting new clients do not suffer from this problem (all clients who meet the targeting are guaranteed to not be in any previous experiments because they are new) while experiments that target the same client subset over and over are most impacted."),(0,i.kt)("h3",{id:"branch-assignment"},"Branch assignment"),(0,i.kt)("p",null,"Assuming a client has satisfied all targeting conditions and bucketed into an experiment, we will randomly assign a branch. Unlike experiments, branches cannot specify targeting conditions, and hashes are re-randomized for every experiment. We do this by:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Assigning buckets equal to the ratios specified in each branch"),(0,i.kt)("li",{parentName:"ol"},"Taking a SHA-256 hash of the ",(0,i.kt)("a",{parentName:"li",href:"#randomization-unit"},"randomization unit")," and the experiment identifier (which is unique per experiment)"),(0,i.kt)("li",{parentName:"ol"},"Checking which range the input hash falls into")),(0,i.kt)("p",null,"For example, given the following branch ratios:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "slug": "experiment-123",\n  "branches": [\n    { "slug": "a", "ratio": 2 },\n    { "slug": "b", "ratio": 5 },\n    { "slug": "c", "ratio": 3 }\n  ]\n}\n')),(0,i.kt)("p",null,"We will assign 20% of the buckets to branch ",(0,i.kt)("inlineCode",{parentName:"p"},"a"),", 50% to ",(0,i.kt)("inlineCode",{parentName:"p"},"b"),", and 30% to ",(0,i.kt)("inlineCode",{parentName:"p"},"c"),". We take a hash of the client's ",(0,i.kt)("inlineCode",{parentName:"p"},"normandy_id")," and the experiment slug (",(0,i.kt)("inlineCode",{parentName:"p"},"experiment-123"),") and see which bucket range it falls into:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"                     hash\n                     v\n  [a, a, b, b, b, b, b, c, c, c]\n\n")),(0,i.kt)("h3",{id:"controlling-interactions"},"Controlling interactions"),(0,i.kt)("p",null,"By default, all experiments are allowed to interact and clients can bucket into multiple experiments simultaneously. However, sometimes we ",(0,i.kt)("em",{parentName:"p"},"do")," want experiments to be exclusive, such as when they change the same set of variables."),(0,i.kt)("p",null,"In practice, we have three methods of preventing interactions between experiments:"),(0,i.kt)("h4",{id:"bucket-range-exclusion"},"Bucket range exclusion"),(0,i.kt)("p",null,"Experiments that configure the same namespace will bucket identically for the same user identifier. This means we can exclude experiments by giving the same namespace and have them specify non-interacting ranges (start / count)."),(0,i.kt)("p",null,"Consider two experiments with the following configurations:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "slug": "experiment-A",\n  "bucketConfig": {\n    "start": 0,\n    "count": 3000,\n    "total": 10000,\n    "namespace": "rutabaga",\n    "randomizationUnit": "normandy_id"\n  }\n},\n{\n  "slug": "experiment-B",\n  "bucketConfig": {\n    "start": 3000,\n    "count": 2000,\n    "total": 10000,\n    "namespace": "rutabaga",\n    "randomizationUnit": "normandy_id"\n  }\n}\n')),(0,i.kt)("p",null,"Say we generate a value of ",(0,i.kt)("inlineCode",{parentName:"p"},"4562")," from our hash on a given client. The client is bucketed into ",(0,i.kt)("inlineCode",{parentName:"p"},"experiment-B")," because this falls in the the range for this experiment (which is ",(0,i.kt)("inlineCode",{parentName:"p"},"3000")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"4999"),")."),(0,i.kt)("p",null,"Note that we ",(0,i.kt)("em",{parentName:"p"},"always")," re-randomize branch assignment, so we can't isolate based on branch."),(0,i.kt)("h4",{id:"client-side-rules"},"Client-side rules"),(0,i.kt)("p",null,"In Nimbus, clients are prevented from enrolling into two experiments that target the same feature with a simple check during enrollment. For example, a user cannot be enrolled in two experiments that change the ",(0,i.kt)("inlineCode",{parentName:"p"},"aboutwelcome")," feature."),(0,i.kt)("p",null,"In Normandy, clients are prevented from enrolling in two experiments that change the same preference."),(0,i.kt)("h4",{id:"targeting-exclusion"},"Targeting exclusion"),(0,i.kt)("p",null,"For specific experiments that should be excluded from others, a targeting expression can be included with a specific experiment identifier:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "targeting": "!activeExperiments[\'some-experiment\']"\n}\n')))}u.isMDXComponent=!0}}]);